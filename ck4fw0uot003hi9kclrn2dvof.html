<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="网络," />










<meta name="description" content="TCP/IP简介 TCP/IP背景和介绍上世纪 70 年代，随着计算机技术的发展，计算机使用者意识到：要想发挥计算机更大的作用，就要将世界各地的计算机连接起来。但是简单的连接是远远不够的，因为计算机之间无法沟通。因此设计一种通用的“语言”来交流是必要可少的，这时 TCP/IP 协议就应运而生了。 TCP/IP（Transmission Control Protocol/Internet Proto">
<meta name="keywords" content="网络">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP&#x2F;IP网络协议基础">
<meta property="og:url" content="http://koenli.github.io/ck4fw0uot003hi9kclrn2dvof.html">
<meta property="og:site_name" content="Koenli&#39;s Blog">
<meta property="og:description" content="TCP/IP简介 TCP/IP背景和介绍上世纪 70 年代，随着计算机技术的发展，计算机使用者意识到：要想发挥计算机更大的作用，就要将世界各地的计算机连接起来。但是简单的连接是远远不够的，因为计算机之间无法沟通。因此设计一种通用的“语言”来交流是必要可少的，这时 TCP/IP 协议就应运而生了。 TCP/IP（Transmission Control Protocol/Internet Proto">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_1.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_2.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_3.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_4.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_5.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_6.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_7.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_8.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_9.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_10.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_11.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_12.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_13.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_14.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_15.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_16.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_17.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_18.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_19.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_20.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_21.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_22.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_23.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_24.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_25.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_26.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_27.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_28.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_29.png">
<meta property="og:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_30.png">
<meta property="og:updated_time" content="2019-02-16T03:37:56.706Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TCP&#x2F;IP网络协议基础">
<meta name="twitter:description" content="TCP/IP简介 TCP/IP背景和介绍上世纪 70 年代，随着计算机技术的发展，计算机使用者意识到：要想发挥计算机更大的作用，就要将世界各地的计算机连接起来。但是简单的连接是远远不够的，因为计算机之间无法沟通。因此设计一种通用的“语言”来交流是必要可少的，这时 TCP/IP 协议就应运而生了。 TCP/IP（Transmission Control Protocol/Internet Proto">
<meta name="twitter:image" content="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://koenli.github.io/ck4fw0uot003hi9kclrn2dvof.html"/>





  <title>TCP/IP网络协议基础 | Koenli's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Koenli's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://koenli.github.io/ck4fw0uot003hi9kclrn2dvof.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Koenli">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Koenli's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TCP/IP网络协议基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-20T19:57:57+08:00">
                2015-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/网络营地/" itemprop="url" rel="index">
                    <span itemprop="name">网络营地</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/ck4fw0uot003hi9kclrn2dvof.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/ck4fw0uot003hi9kclrn2dvof.html" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/ck4fw0uot003hi9kclrn2dvof.html" class="leancloud_visitors" data-flag-title="TCP/IP网络协议基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="TCP-IP简介"><a href="#TCP-IP简介" class="headerlink" title="TCP/IP简介"></a>TCP/IP简介</h1><hr>
<h2 id="TCP-IP背景和介绍"><a href="#TCP-IP背景和介绍" class="headerlink" title="TCP/IP背景和介绍"></a>TCP/IP背景和介绍</h2><p>上世纪 70 年代，随着计算机技术的发展，计算机使用者意识到：要想发挥计算机更大的作用，就要将世界各地的计算机连接起来。但是简单的连接是远远不够的，因为计算机之间无法沟通。因此设计一种通用的“语言”来交流是必要可少的，这时 TCP/IP 协议就应运而生了。</p>
<p>TCP/IP（Transmission Control Protocol/Internet Protocol）是传输控制协议和网络协议的简称，它定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。</p>
<p>TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 IP 协议、IMCP 协议、TCP 协议、以及 http、ftp、pop3 协议等。网络中的计算机都采用这套协议族进行互联。</p>
<h3 id="网络协议栈架构"><a href="#网络协议栈架构" class="headerlink" title="网络协议栈架构"></a>网络协议栈架构</h3><p>提到网络协议栈结构，最著名的当属 OSI 七层模型，但是 TCP/IP 协议族的结构则稍有不同，它们之间的层次结构有如图对应关系：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_1.png" alt=""></p>
<p>可见 TCP/IP 被分为 4 层，每层承担的任务不一样，各层的协议的工作方式也不一样，每层封装上层数据的方式也不一样：</p>
<blockquote>
<ul>
<li>应用层：应用程序通过这一层访问网络，常见 FTP、HTTP、DNS 和 TELNET 协议</li>
<li>传输层：TCP 协议和 UDP 协议</li>
<li>网络层：IP 协议，ARP、RARP 协议，ICMP 协议等</li>
<li>网络接口层：是 TCP/IP 协议的基层，负责数据帧的发送和接收</li>
</ul>
</blockquote>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_2.png" alt=""></p>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>网络上每一个节点都必须有一个独立的 IP 地址，通常使用的 IP 地址是一个 32bit 的数字，被 . 分成 4 组，例如，255.255.255.255 就是一个 IP 地址。有了 IP 地址，用户的计算机就可以发现并连接互联网中的另外一台计算机。</p>
<p>在 Linux 系统中，可以用这样一条命令查看自己的 IP 地址：</p>
<pre><code># ifconfig -a 
</code></pre><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>用 12 位数字组成的 IP 地址很难记忆，在实际应用时，用户一般不需要记住 IP 地址，互联网给每个 IP 地址起了一个别名，习惯上称作域名。</p>
<p>域名与计算机的 IP 地址相对应，并把这种对应关系存储在域名服务系统 DNS(Domain Name Service)中，这样用户只需记住域名就可以与指定的计算机进行通信了。</p>
<p>常见的域名包括 com、net 和 org 三种顶级域名后缀，除此之外每个国家还有自己国家专属的域名后缀（比如我国的域名后缀为 cn）。目前经常使用的域名诸如百度（<a href="www.baidu.com">www.baidu.com</a>）、Linux 组织（<a href="www.lwn.net">www.lwn.net</a>）等等。</p>
<p>我们可以使用命令”<code>nslookup</code>”、“<code>dig</code>”或者“<code>ping</code>”来查看与域名相对应的 IP 地址</p>
<pre><code># ping www.baidu.com
# dig www.baidu.com
</code></pre><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC（Media Access Control）地址，或称为物理地址、硬件地址，用来定义互联网中设备的位置。</p>
<p>在 TCP/IP 层次模型中，网络层管理 IP 地址，链路层则负责 MAC 地址。因此每个网络位置会有一个专属于它的 IP 地址，而每个主机会有一个专属于它 MAC 地址。</p>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>IP 地址是用来发现和查找网络中的地址的，但是不同程序如何互相通信呢，这就需要端口号来识别了。如果把 IP 地址比作一间房子 ，端口就是出入这间房子的门。真正的房子只有几个门，但是端口采用 16 比特的端口号标识，一个 IP 地址的端口可以有 65536（即：2^16）个之多！</p>
<p>服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 25，FTP（文件传输协议）服务器的 TCP 端口号都是 21，TFTP(简单文件传输协议)服务器的 UDP 端口号都是 69。任何 TCP/IP 实现所提供的服务都用众所周知的 1－1023 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority, IANA）来管理。</p>
<h3 id="封装与分用"><a href="#封装与分用" class="headerlink" title="封装与分用"></a>封装与分用</h3><p><strong>封装：</strong>当应用程序发送数据的时候，数据在协议层次当中从顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，如下图所示，传输层传给网络层的数据单元称作 <strong>TCP 报文段</strong>(TCP segment) 或 <strong>UDP数据报</strong>(UDP datagram) 。网络层传给链路层的数据单元称作 <strong>IP 数据报</strong>(IP datagram)。链路层上的传输单元称作<strong>帧</strong>(Frame)。</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_3.png" alt=""></p>
<p><strong>分用：</strong>当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。</p>
<h3 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h3><p>RFC（Request for Comment）文档是所有以太网协议的正式标准，并在其官网上面公布，由 IETF 标准协会制定。大量的 RFC 并不是正式的标准，出版的目的只是为了提供信息。RFC 的篇幅不一，从几页到几百页不等。每一种协议都用一个数字来标识，如 RFC 3720 是 iSCSI 协议的标准，数字越大说是 RFC 的内容越新或者是对应的协议（标准）出现的比较晚。</p>
<p>所有的 RFC 文档都可以从网络上找到，其官网为<a href="http://www.ietf.org/" target="_blank" rel="noopener">IETF</a>。在网站上面可以通过分类以及搜索快速找到目标协议的 RFC 文档。目前在 IETF 网站上面的 RFC 文档有数千个，但是我们不需要全部掌握，在工作或学习中如果遇到可以找到对应的解释，理论与实际结合会有更好地效果，单纯阅读 RFC 的效果一般。</p>
<h1 id="链路层介绍"><a href="#链路层介绍" class="headerlink" title="链路层介绍"></a>链路层介绍</h1><hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络层协议的数据单元是 <strong>IP 数据报</strong> ，而数据链路层的工作就是把网络层交下来的 IP 数据报 封装为 <strong>帧</strong>（frame）发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。 为达到这一目的，数据链路必须具备一系列相应的功能，主要有：</p>
<blockquote>
<ul>
<li>将数据封装为帧（frame），帧是数据链路层的传送单位</li>
<li>控制帧的传输，包括处理传输差错，调节发送速率与接收方相匹配</li>
<li>在两个网络实体之间提供数据链路通路的建立、维持和释放的管理</li>
</ul>
</blockquote>
<p>数据帧的结构是这样的：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_4.png" alt=""></p>
<h2 id="控制帧的传输"><a href="#控制帧的传输" class="headerlink" title="控制帧的传输"></a>控制帧的传输</h2><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>通信系统必须具备发现差错的能力，并采取措施纠正之，使差错控制在所能允许的尽可能小的范围内，这就是差错控制过程，也是数据链路层的主要功能之一。</p>
<h4 id="反馈重发"><a href="#反馈重发" class="headerlink" title="反馈重发"></a>反馈重发</h4><p>接收方通过对差错编码(奇偶校验码或 CRC 码)的检查，可以判定一帧在传输过程中是否发生了差错。一旦发现差错，一般可以采用<strong>反馈重发</strong>的方法来纠正。这就要求接受方收完一帧后，向发送方反馈一个接收是否正确的信息，使发送方据此做出是否需要重新发送的决定。发送方仅当收到接收方已正确接收的反馈信号后才能认为该帧已经正确发送完毕，否则需要重发直至正确为止。</p>
<h4 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h4><p>如果某一帧发送出现问题，一直不能发送成功，为了避免传输过程停滞不前，通常引入 <strong>计时器</strong> (Timer) 来限定接收方发回反馈消息的时间间隔。当发送方发送一帧的同时也启动计时器，若在限定时间间隔内未能收到接收方的反馈信息，即计时器超时(Timeout)，则可认为传出的帧以出错或丢失，就要重新发送。</p>
<h4 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h4><p>由于同一帧数据可能被重复发送多次，就可能引起接收方多次收到同一帧并将其递交给网络层的情况。为了防止这种情况，可以采用对发送的帧编号的方法，即赋予每帧一个序号，从而使接收方能从该序号来区分是新发送来的帧还是重发的帧，以此来确定要不要将接收到的帧递交给网络层。</p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>由于收发双方各自使用的设备工作速率和缓冲存储空间的差异，可能出现发送方的发送能力大于接收方接收能力的现象，此时若不对发送方的发送速率做适当的限制，前面来不及接收的帧将被后面不断发送来的帧“淹没”，从而造成帧的丢失而出错。</p>
<p>由此可见，流量控制实际上是对发送方数据流量的控制，使其发送速率不超过接收方的速率。所以需要一些规则使得发送方知道在什么情况下可以接着发送下一帧，而在什么情况下必须暂停发送，以等待收到某种反馈信息后再继续发送。这就是流量控制。</p>
<h2 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h2><p>以太网(Ether-net)是指 DEC 公司、Intel 公司和 Xerox 公司在 1982 年联合公布的一个标准，这个标准里面使用了一种称作 CSMA/CD 的接入方法。而 IEEE802 提供的标准集 802.3(还有一部分定义到了 802.2 中)也提供了一个 CSMA/CD 的标准。</p>
<p>这两个标准稍有不同，因此链路层数据帧的的封装格式也有所不同（数据帧中的地址为 MAC 地址）：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_5.png" alt=""></p>
<h2 id="PPP（点对点协议）"><a href="#PPP（点对点协议）" class="headerlink" title="PPP（点对点协议）"></a>PPP（点对点协议）</h2><p>PPP（点到点协议）是为在同等单元之间传输数据设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据。设计目的主要是用来通过 <strong>拨号或专线</strong> 方式建立 <strong>点对点</strong> 连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</p>
<p>点对点协议（PPP）为在点对点连接上传输多协议数据包提供了一个标准方法。PPP 最初设计是为两个对等节点之间的 IP 流量传输提供一种封装协议。在 TCP/IP 协议集中它是一种用来同步调制连接的数据链路层协议。</p>
<h2 id="SLIP-与-PPP"><a href="#SLIP-与-PPP" class="headerlink" title="SLIP 与 PPP"></a>SLIP 与 PPP</h2><h3 id="SLIP协议"><a href="#SLIP协议" class="headerlink" title="SLIP协议"></a>SLIP协议</h3><p>SLIP 的全称为 Serial Line IP（串行线路 IP）。它是一种对 IP 数据报进行封装的简单形式。 SLIP 协议规定的帧格式规则：</p>
<blockquote>
<ul>
<li>IP 数据报以一个称作 END（0xc0）的特殊字符结束。同时为了防止数据报传输之前的线路噪音被误认为是数据报内容，在数据报开始处添加一个 END 字符</li>
<li>如果 IP 数据报中含有 END 字符，就连续传输 0xdb 和 0xdc 来取代它。0xdb 是 SLIP 的 ESC 字符，但它的值与 ASCⅡ码中的 ESC（0x1b）不同</li>
<li>如果 IP 数据报中含有 ESC 字符，就连续传输 0xdb 和 0xdd 来取代它</li>
</ul>
</blockquote>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_6.png" alt=""></p>
<p>SLIP 的缺陷：</p>
<blockquote>
<ul>
<li>每一端必须知道对端的 IP 地址，没有办法把本端 IP 地址传递给对端</li>
<li>数据帧中无类型字段，当一条串行线路使用 SLIP 时则不能使用其他协议</li>
<li>SLIP 数据帧中无 checksum，只能依靠上层协议来发现和纠正错误</li>
</ul>
</blockquote>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><p>PPP 协议修改了 SLIP 协议中的缺陷，包括以下三个部分：</p>
<blockquote>
<ul>
<li>PPP 封装 IP 数据报既支持数据为 8 位和无奇偶校验的异步模式，又支持面向比特的同步链接</li>
<li>通过 LCP（链路控制协议）允许双方进行协商</li>
<li>通过 NCP（网络控制协议）允许双方在网络层上进行协商</li>
</ul>
</blockquote>
<p>PPP 协议的字符规则与 SLIP 有所不同：</p>
<blockquote>
<ul>
<li>PPP 帧以标志字符 0x7e 开始和结束，紧接着是一个值为 0xff 的地址字节，然后是一个值为 0x03 的控制字节</li>
<li>由于标志字符是 0x7e，当它出现在信息字段中时，需要连续传送 0x7d 和 0x5e 来替代它</li>
<li>当在信息字段中遇到 0x7d 时，需要连续传送 0x7d 和 0x5d 来替代它</li>
<li>默认情况下，如果字符的值小于 0x20，需要连续传送 0x7d 和 0x21 来替代它</li>
</ul>
</blockquote>
<p>PPP 与 SLIP 相比具有下列优点：</p>
<blockquote>
<ul>
<li>PPP 支持在单根串行线路上运行多种网络层协议</li>
<li>每一帧都有 CRC 校验</li>
<li>通信双方可以用 NCP 进行 IP 地址的动态协商</li>
<li>可以类似于 CSLIP 对 TCP 和 IP 首部进行压缩</li>
<li>LCP 可以对多个数据链路选项进行设置</li>
</ul>
</blockquote>
<h2 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h2><p>为了提供足够快的响应时间，以太网和 IEEE802.3 对数据帧长度都有限制，其最大值分别为 1500 字节和 1492 字节，链路层的这个特性称作 <strong>MTU</strong> ，即 <strong>最大传输单元</strong> 。</p>
<p>当网络层传下来一个 IP 数据报，并且其长度比链路层的 MTU 大，那么网络层就需要对数据报进行分片，使每一片都小于 MTU。</p>
<p>MTU 分为接口 MTU 和路径 MTU：接口 MTU 是所指定的接口所允许发送的最大数据长度；路径 MTU 指两台通信主机路径中最小的 MTU 值。路径 MTU 是不对称的，它在两个方向上不一定一致。</p>
<p>用命令 netstat -in 可以查看网络接口的 MTU:</p>
<pre><code>netstat -in
</code></pre><h1 id="IP-网际协议"><a href="#IP-网际协议" class="headerlink" title="IP 网际协议"></a>IP 网际协议</h1><hr>
<p>IP 协议位于网络层，它是 TCP/IP 协议族中最为核心的协议，所有的 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。IP 协议提供的是 <strong>不可靠</strong> 、 <strong>无连接</strong> 的数据报传送服务。</p>
<p><strong>不可靠</strong>（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。</p>
<p><strong>无连接</strong>（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。</p>
<h2 id="IP数据报"><a href="#IP数据报" class="headerlink" title="IP数据报"></a>IP数据报</h2><p>首先看一下 IP 数据报的格式，其中没有一个字段是多余的，学习 IP 协议就应从学习它的报文字段意义和作用开始。</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_7.png" alt=""></p>
<p>如上图所示，普通的 IP 数据报的<strong>报头</strong>长度 20 字节(除非有选项字段)，各个部分的作用：</p>
<p><strong>版本号</strong> ：4 位，用于标明 IP 版本号，0100 表示 IPv4，0110 表示 IPv6。目前常见的是 IPv4。</p>
<p><strong>首部长度</strong> ：4 位，表示 IP 报头长度，包括选项字段。</p>
<p><strong>服务类型(TOS)</strong> ：分别有：最小时延、最大吞吐量、最高可靠性、最小花费 4 种服务，如下图所示。4 个标识位只能有一个被置为 1 ：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_8.png" alt=""></p>
<p><strong>总长度</strong> ：16 位，报头长度加上数据部分长度，便是数据报的总长度。IP 数据报最长可达 65535 字节。</p>
<p><strong>标识</strong> ：16 位，接收方根据分片中的标识字段相不相同来判断这些分片是不是同一个数据报的分片，从而进行分片的重组。通常每发送一份报文它的值就会加 1。</p>
<p><strong>标志</strong> ：3 位，用于标识数据报是否分片。其中的第 2 位是不分段（DF）位。当 DF 位被设置为 1 时，则不对数据包进行分段处理；第 3 位是分段（MF）位，除了最后一个分段的 MF 位被设置为 0 外，其他的分段的 MF 位均设置为 1。</p>
<p><strong>偏移</strong> ：13 位，在接收方进行数据报重组时用来标识分片的顺序。</p>
<p><strong>生存时间(TTL)</strong> ：8 位，用于设置数据报可以经过的最多的路由器个数。TTL 的初始值由源主机设置（通常为 32 或 64），每经过一个处理它的路由器，TTL 值减 1。如果一个数据报的 TTL 值被减至 0，它将被丢弃。</p>
<p><strong>协议</strong> ：8 位，用来标识是哪个协议向 IP 传送数据。ICMP 为 1，IGMP 为 2，TCP 为 6，UDP 为 17，GRE 为 47，ESP 为 50。</p>
<p><strong>首部校验和</strong> ：根据 IP 首部计算的校验和码。</p>
<p><strong>源 IP 和目的 IP</strong> ：数据报头还会包含该数据报的发送方 IP 和接收方 IP。</p>
<p><strong>选项</strong> ：是数据报中的一个可变长、可选的信息，不常用，多用于安全、军事等领域。</p>
<h2 id="IP-地址分类"><a href="#IP-地址分类" class="headerlink" title="IP 地址分类"></a>IP 地址分类</h2><p>为了便于寻址以及层次化构造网络，每个 IP 地址可被看作是分为两部分，即 <strong>网络号</strong> 和 <strong>主机号</strong> 。同一个区域的所有主机有相同的网络号(即 IP 地址的前半部分相同)，区域内的每个主机（包括路由器）都有一个主机号与其对应。</p>
<p>IP 地址被分为 A,B,C,D,E 五类，其中 A 类给大型网络或政府机构等，B 类分配给中型网络、跨国企业等，C 类分配给小型网络，D 类用于多播，E 类用于实验，各类可容纳的地址数目不同。其中我们最常见的为 A,B,C 这三类。</p>
<p>IP 地址用 32 位二进制数字表示的时候，A,B,C 类 IP 的网络号长度分别为 8 位、16 位、24 位：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_9.png" alt=""></p>
<p><strong>A 类地址</strong></p>
<blockquote>
<ul>
<li>A 类地址网络号范围：1.0.0.0—127.0.0.0</li>
<li>A 类 IP 地址范围：1.0.0.0—127.255.255.255</li>
<li>A 类 IP 的私有地址范围：10.0.0.0—10.255.255.255 （所谓的私有地址就是在互联网上不使用，而被用在局域网络中的地址）</li>
<li>127.X.X.X 是保留地址，用做循环测试用的</li>
<li>因为主机号有 24 位，所以一个 A 类网络号可以容纳 2^24-2=16777214 个主机号</li>
</ul>
</blockquote>
<p><strong>B 类地址</strong></p>
<blockquote>
<ul>
<li>B 类地址网络号范围：128.0.0.0—191.255.0.0</li>
<li>B 类 IP 地址范围：128.0.0.0—191.255.255.255</li>
<li>B 类 IP 的私有地址范围：172.16.0.0—172.31.255.255</li>
<li>169.254.X.X 是保留地址；191.255.255.255 是广播地址</li>
<li>因为主机号有 16 位，所以一个 B 类网络号可以容纳 2^16-2=65534 个主机号</li>
</ul>
</blockquote>
<p><strong>C 类地址</strong></p>
<blockquote>
<ul>
<li>C 类地址网络号范围：192.0.0.0—223.255.255.0</li>
<li>C 类 IP 地址范围：192.0.0.0—223.255.255.255</li>
<li>C 类 IP 的私有地址范围：192.168.0.0—192.168.255.255</li>
<li>因为主机号有 8 位，所以一个 C 类网络号可以容纳 2^8-2=254 个主机号</li>
</ul>
</blockquote>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>IP 地址如果只使用 ABCDE 类来划分，会造成大量的浪费：一个有 500 台主机的网络，无法使用 C 类地址。但如果使用一个 B 类地址，6 万多个主机地址只有 500 个被使用，造成 IP 地址的大量浪费。</p>
<p>因此，可以在 ABC 类网络的基础上，进一步划分子网：<strong>占用主机号的前几个位，用于表示子网号 </strong>。</p>
<p>这样 IP 地址就可看作 IP = 网络号 + 子网号 + 主机号</p>
<p>子网号的位数没有硬性规定，于是我们用 <strong>子网掩码</strong> 来确定一个 IP 地址中哪几位是主机号，具体使用方法如图：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_10.png" alt=""></p>
<p>子网掩码中的 1 标识了 IP 地址中相应的网络号，0 标识了主机号。将 IP 地址和子网掩码进行 <strong>逻辑与运算</strong> ，结果就能得到网络号和子网号。</p>
<h2 id="IP-路由选择"><a href="#IP-路由选择" class="headerlink" title="IP 路由选择"></a>IP 路由选择</h2><p>如果发送方与接收方直接相连（点对点）或都在一个共享网络上（以太网），那么 IP 数据报就能直接送达。 而大多数情况则是发送方与接收方通过若干个路由器(router)连接，那么数据报就需要经过若干个路由器的转发才能送达，它是怎么选择一个合适的路径来”送货”的呢？</p>
<p>IP 层在内存中有一个路由表（输入命令 <code>route -n</code>可以查看路由表），当收到一份数据报并进行发送时，都要对该表进行搜索：</p>
<blockquote>
<p>1、搜索路由表，如果能找到和目的 IP 地址完全一致的主机，则将 IP 数据报发向该主机；</p>
</blockquote>
<blockquote>
<p>2、搜索路由表，如果匹配主机失败，则匹配同子网的路由器(这需要子网掩码的协助)。如果找到路由器，则将 IP 该数据报发向该路由器；</p>
</blockquote>
<blockquote>
<p>3、搜索路由表，如果匹配同子网路由器失败，则匹配同网络号路由器，如果找到路由器，则将该 IP 数据报发向该路由器；</p>
</blockquote>
<blockquote>
<p>4、如果以上都失败了，就搜索默认路由，如果默认路由存在，则发报；</p>
</blockquote>
<blockquote>
<p>5、如果都失败了，就丢掉这个包；</p>
</blockquote>
<blockquote>
<p>6、接收到数据报的路由器再按照它自己的路由表继续转发，直到数据报被转发到目的主机；</p>
</blockquote>
<blockquote>
<p>7、如果在转发过程中，IP 数据报的 TTL（生命周期）已经被减为 0，则该 IP 数据报就被抛弃。</p>
</blockquote>
<h2 id="NAT-技术"><a href="#NAT-技术" class="headerlink" title="NAT 技术"></a>NAT 技术</h2><p>当你用 ifconfig 查看 IP 地址时，有时你会发现自己的 IP 地址是这样的———192.186.X.X 或 172.16.X.X<br>这是 C 类网和 B 类网的私有地址，这就是俗称的内网 IP。这是因为你的路由器采用了 NAT 技术。</p>
<p>NAT（Network Address Translation，网络地址转换）是 1994 年提出的。当在专用网内部的一些主机本来已经分配到了内网 IP 地址，但现在又想和因特网上的主机通信时，NAT 技术将其内网 IP 地址转换成全球 IP 地址，然后与因特网连接，也就是说，内网的数台主机使用了同一个全球 IP 地址在上网。</p>
<p>NAT 技术实现了宽带共享，而且有助于缓解 IP 地址空间枯竭的问题。</p>
<h2 id="IP-的未来"><a href="#IP-的未来" class="headerlink" title="IP 的未来"></a>IP 的未来</h2><p>我们现在使用的 IPv4 协议版本从理论上讲，可以编址 1600 万个网络、40 亿台主机。但采用 A、B、C 三类编址方式后，可用的网络地址和主机地址的数目大打折扣，以至 IP 地址 已于 <strong>2011 年 2 月 3 日分配完毕</strong> 。 其中北美占有 3/4，约 30 亿个，而人口最多的亚洲只有不到 4 亿个，中国截止 2010 年 6 月 IPv4 地址数量达到 2.5 亿，落后于 4.2 亿网民的需求。地址不足，严重地制约了中国及其他国家互联网的应用和发展。</p>
<p>随着网络技术的发展，计算机网络将进入人们的日常生活，可能身边的每一样东西都需要连入全球因特网，在这样的环境下，IPv6 应运而生。</p>
<p>IPv6 的地址长度是 128 位，通常将这 128 位的地址按每 16 位划分为一个段，将每个段转换成十六进制数字，并用冒号隔开，比如：2000:0000:0000:0000:0001:2345:6789:abcd 就是一个 IPv6 地址。</p>
<p>单从数量级上来说，IPv6 所拥有的地址容量是 IPv4 的约 8×10^28 倍，达到 2^128（算上全零的）个。这不但解决了网络地址资源数量的问题，同时也为除电脑外的设备连入互联网在数量限制上扫清了障碍。</p>
<p>随着 IPv4 不足，支持 IPv6 的网络迅速增长，现在全球已经有 5%的网络使用 IPv6</p>
<h1 id="网络层其它协议"><a href="#网络层其它协议" class="headerlink" title="网络层其它协议"></a>网络层其它协议</h1><hr>
<p>网络层不仅有 IP 协议，还有其它如 ARP、ICMP 等其它协议。</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_11.png" alt=""></p>
<h2 id="ARP-Address-Resolution-Protocol-地址解析协议"><a href="#ARP-Address-Resolution-Protocol-地址解析协议" class="headerlink" title="ARP(Address Resolution Protocol)地址解析协议"></a>ARP(Address Resolution Protocol)地址解析协议</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>当主机通过数据链路发送数据的时候， <strong>IP 数据报</strong> 会先被封装为一个 <strong>数据帧</strong> ，而 <strong>MAC 地址</strong> 会被添加到数据帧的 <strong>报头</strong> （链路层介绍时已讲过）。 ARP 便是在这个过程中通过目标主机的 IP 地址，查询目标主机的 MAC 地址。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在你的电脑和路由器中都有一个 <strong>ARP 缓存表</strong> ，其中保存的是近期<strong>(20 分钟)</strong>与自己有过通信的主机的 IP 地址与 MAC 地址的对应关系。</p>
<p>ARP 缓存表使用过程：</p>
<blockquote>
<ul>
<li>当主机要发送一个 IP 数据报的时候，会首先查询一下自己的 ARP 缓存表；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果在 ARP 缓存表中找到对应的 MAC 地址，则将 IP 数据报封装为数据帧，把 MAC 地址放在帧首部，发送数据帧；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果查询的 IP－MAC 值对不存在，那么主机就向网络中广播发送一个 ARP 请求数据帧，ARP 请求中包含待查询 IP 地址；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>网络内所有收到 ARP 请求的主机查询自己的 IP 地址，如果发现自己符合条件，就回复一个 ARP 应答数据帧，其中包含自己的 MAC 地址；</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>收到 ARP 应答后，主机将其 IP - MAC 对应信息存入自己的 ARP 缓存，然后再据此封装 IP 数据报，再发送数据帧。</li>
</ul>
</blockquote>
<p>你可以通过命令 <code>arp -a</code> 查看 ARP 缓存表(表项记录 20 分钟超时)，这里还有其它 ARP 命令可以对缓存表做查看、修改：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_12.png" alt=""></p>
<h3 id="ARP代理"><a href="#ARP代理" class="headerlink" title="ARP代理"></a>ARP代理</h3><p>如果 ARP 请求是从一个网络上的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该 ARP 请求，这个过程称作 <strong>代理 ARP（Proxy ARP）</strong>。</p>
<p>当连接这两个网络的路由器收到该 ARP 请求时，它会发现自己有通向目的主机的路径，随后它会将自己(路由器)的 MAC 地址回复给源主机。源主机会认为路由器的 MAC 地址就是目的主机的 MAC 地址，而对于随后发来的数据帧，路由器会转发到它后面真实 MAC 地址的目的主机。</p>
<p>两个物理网络之间的路由器可以使这两个网络彼此透明化，在这种情况下，只要路由器设置成一个 ARP 代理，以响应一个网络到另一个网络主机的 ARP 请求，两个物理网络就可以使用相同的网络号。</p>
<h3 id="ARP-欺骗"><a href="#ARP-欺骗" class="headerlink" title="ARP 欺骗"></a>ARP 欺骗</h3><p>从 ARP 代理的原理可以看出来：IP - MAC 的对应信息很容易被伪造！黑客可以伪造 ARP 应答数据帧而欺骗 ARP 请求者，从而达到截获数据的目的。</p>
<h2 id="RARP-Reverse-Address-Resolution-Protocol-逆向地址解析协议"><a href="#RARP-Reverse-Address-Resolution-Protocol-逆向地址解析协议" class="headerlink" title="RARP(Reverse Address Resolution Protocol)逆向地址解析协议"></a>RARP(Reverse Address Resolution Protocol)逆向地址解析协议</h2><p>听名字就知道，RARP 与 ARP 是相反的关系，用于将 MAC 地址转换为 IP 地址。对应于 ARP，RARP 请求以广播方式传送，而 RARP 应答一般是单播传送的。</p>
<p>某些设备，比如无盘机在启动时可能不知道自己的 IP 地址，它们可以将自己的 MAC 地址使用 RARP 请求广播出去，RARP 服务器就会响应并回复无盘机的 IP 地址。</p>
<p>RARP 在目前的应用中已极少被使用，不再赘述了。</p>
<h2 id="ICMP-Internet-Control-Message-Protocol-控制报文协议"><a href="#ICMP-Internet-Control-Message-Protocol-控制报文协议" class="headerlink" title="ICMP(Internet Control Message Protocol)控制报文协议"></a>ICMP(Internet Control Message Protocol)控制报文协议</h2><p>通信过程中的发生各种问题时，ICMP 将问题反馈，通过这些信息，管理者可以对所发生的问题作出诊断，然后采取适当的措施去解决它。</p>
<p>ICMP 报文由 8 位错误类型、8 位条件代码和 16 位校验和组成，被封装在一个 IP 数据报中：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_13.png" alt=""></p>
<p>报文的类型字段可以有 15 个不同的值，以便描述特定类型的 ICMP 报文，代码字段的值进一步描述不同的条件，各类型的报文及其处理方法如图所示：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_14.png" alt=""></p>
<p>也有一些出现差错而不产生 ICMP 报文的情况：</p>
<blockquote>
<ul>
<li>1.ICMP 差错报文</li>
<li>2 . 目的地址是广播或多播地址</li>
<li>3.作为链路层广播的数据报</li>
<li>4.不是 IP 分片的第一片</li>
<li>5.源地址不是单个主机的数据报（源不能为零地址、环回地址、广播多播地址）</li>
</ul>
</blockquote>
<h2 id="ping-程序和-traceroute-程序"><a href="#ping-程序和-traceroute-程序" class="headerlink" title="ping 程序和 traceroute 程序"></a>ping 程序和 traceroute 程序</h2><p>ping 程序和 traceroute 程序是两个常见的 基于 <strong>ICMP</strong> 协议 的工具。</p>
<h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>ping 程序是对两台主机之间连通性进行测试的基本工具，它只是利用 ICMP 回显请求和回显应答报文，而不用经过传输层（TCP/UDP）。</p>
<p>ping 程序通过在 ICMP 报文数据中存放发送请求的时间值来计算往返时间，当应答返回时，用当前时间减去存放在 ICMP 报文中的时间值，即是往返时间。</p>
<p>ping 程序使用方法为 <strong>ping IP 地址</strong> ，ping 命令还可以加上参数，实现更多的功能：</p>
<blockquote>
<ul>
<li>-n 只输出数值。</li>
<li>-q 不显示任何传送封包的信息，只显示最后的结果。</li>
<li>-r 忽略普通的 Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</li>
<li>-R 记录路由过程。</li>
<li>-v 详细显示指令的执行过程。</li>
<li>-c 数目：在发送指定数目的包后停止。</li>
<li>-i 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</li>
<li>-t 存活数值：设置存活数值 TTL 的大小。</li>
</ul>
</blockquote>
<h3 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h3><p>traceroute 程序是用来侦测主机到目的主机之间所经路由情况的重要工具。刚才 ping 程序中讲过，带 -R 参数的 ping 命令也可以记录路由过程，但是，因为 IP 数据报头的长度限制(最多能保存 9 个 IP 地址)，ping 不能完全的记录下所经过的路由器，traceroute 正好就填补了这个缺憾。</p>
<p>traceroute 程序的工作原理很简单：</p>
<blockquote>
<ul>
<li>它发送一份 TTL 为 1 的 IP 数据报给目的主机，经过第一个路由器时，TTL 值被减为 0，则第一个路由器丢弃该数据报，并返回一份超时 ICMP 报文，于此得到了路径中第一个路由器的地址</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>然后再发送一份 TTL 值为 2 的数据报，便可得到第二个路由器的地址</li>
</ul>
</blockquote>
<p>-以此类推，一直到到达目的主机为止，这样便记录下了路径上所有的路由 IP。</p>
<h2 id="IGMP-Internet-Group-Management-Protocol-组管理协议"><a href="#IGMP-Internet-Group-Management-Protocol-组管理协议" class="headerlink" title="IGMP(Internet Group Management Protocol)组管理协议"></a>IGMP(Internet Group Management Protocol)组管理协议</h2><p>IGMP 是用于管理多播组成员的一种协议，它的作用在于，让其他所有需要知道自己处于哪个多播组的主机和路由器知道自己的状态。只要某一个多播组还有一台主机，多播路由器就会把数据传输出去，这样，接受方就会通过网卡过滤功能来得到自己想要的数据。 为了知道多播组的信息，多播路由器需要定时的发送 IGMP 查询，各个多播组里面的主机要根据查询来回复自己的状态。路由器来决定有几个多播组，自己要对某一个多播组发送什么样的数据。</p>
<h1 id="传输层：UDP协议"><a href="#传输层：UDP协议" class="headerlink" title="传输层：UDP协议"></a>传输层：UDP协议</h1><hr>
<h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p>从之前介绍的网络层协议来看，通信的两端是两台主机，IP 数据报首部就标明了这两台主机的 IP 地址。但是从传输层来看，是发送方主机中的一个<strong>进程</strong>与接收方主机中的一个<strong>进程</strong>在交换数据，因此，严格地讲，通信双方不是主机，而是主机中的<strong>进程</strong>。</p>
<p>主机中常常有多个应用进程同时在与外部通信(比如你的浏览器和 QQ 在同时运行)，下图中，A 主机的 AP1 进程在于 B 主机的 AP3 进程通信，同时主机 A 的 AP2 进程也在与 B 主机的 AP4 进程通信。</p>
<p>两个主机的传输层之间有一个灰色双向箭头，写着“传输层提供应用进程间的逻辑通信”。 <strong>逻辑通信</strong>：看起来是数据似乎是沿着双向箭头在传输层水平传输的，但实际上是沿图中的虚线经多个协议层次而传输。</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_15.png" alt=""></p>
<p>TCP/IP 协议栈传输层有两个重要协议——UDP 和 TCP，不同的应用进程在传输层使用 TCP 或 UDP 之一：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_16.png" alt=""></p>
<h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>刚才的图中，AP1 与 AP3 的通信与 AP2 与 AP4 的通信可以使用同一个传输层协议来传输(TCP 或 UDP)，根据 IP 地址或 MAC 地址都只能是把数据传到正确的主机，但具体需要传到哪一个进程，是通过端口来辨认的。比如同时使用浏览器和 QQ，浏览器占用 80 端口，而 QQ 占用 4000 端口，那么发送过来的 QQ 消息便会通过 4000 端口显示在 QQ 客户端，而不会错误地显示在浏览器上。</p>
<p>端口号有 0～65535 的编号，其中：</p>
<blockquote>
<ul>
<li>编号 0～1023 为 系统端口号 ，这些端口号可以在网址 <a href="http://www.iana.org" target="_blank" rel="noopener">www.iana.org</a> 查询到，它们被指派给了 TCP/IP 最重要的一些应用程序，以下是一些常见的系统端口号：</li>
</ul>
</blockquote>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_17.png" alt=""></p>
<blockquote>
<ul>
<li>编号 1024～49151 为 登记端口号 ，为没有系统端口号的应用程序使用，使用这类端口号必须在 IANA 按规定手续登记，以防止重复。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>编号 49152～65535 为 短暂端口号 ，是留给客户进程选择暂时使用的，使用结束后，这类端口号会被放开以供其它程序使用。</li>
</ul>
</blockquote>
<h2 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h2><p>UDP(User Datagram Protocol)用户数据报协议，它只在 IP 数据报服务之上增加了很少一点功能，它的主要特点有：</p>
<blockquote>
<ul>
<li>(1).UDP 是无连接的，发送数据之前不需要建立连接(而 TCP 需要)，减少了开销和时延。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(2).UDP尽最大努力交付，不保证交付可靠性。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(3).UDP 是面向报文的，对于从应用层交付下来的 应用层数据报，只做很简单的封装(8 字节 UDP 报头)，首部开销小。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(4).UDP 没有拥塞控制，出现网络拥塞时发送方也不会降低发送速率。这种特性对某些实时应用是很重要的，比如 IP 电话，视频会议等，它们允许拥塞时丢失一些数据，因为如果不抛弃这些数据，极可能造成时延的累积。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(5).UDP 支持一对一、一对多、多对一和多对多的交互通信。</li>
</ul>
</blockquote>
<p>从应用层到传输层，再到网络层的各层次封装：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_18.png" alt=""></p>
<h2 id="UDP报文"><a href="#UDP报文" class="headerlink" title="UDP报文"></a>UDP报文</h2><p>UDP 数据报可分为两部分：UDP 报头和数据部分。其中数据部分是应用层交付下来的数据。UDP 报头总共 8 字节，而这 8 字节又分为 4 个字段：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_19.png" alt=""></p>
<blockquote>
<ul>
<li><strong>源端口</strong> 2 字节 在对方需要回信时可用，不需要时可以全 0</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>目的端口</strong> 2 字节 必须，也是最重要的字段</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>长度</strong> 2 字节 长度值包括报头和数据部分</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>校验和</strong> 2 字节 用于检验 UDP 数据报在传输过程中是否有出错，有错就丢弃</li>
</ul>
</blockquote>
<h2 id="tcpdump-抓取-UDP-报文"><a href="#tcpdump-抓取-UDP-报文" class="headerlink" title="tcpdump 抓取 UDP 报文"></a>tcpdump 抓取 UDP 报文</h2><p>现在我们动手实践，尝试抓取一个 UDP 数据报，并解读其内容。</p>
<p>我们需要编写一个小程序，用于向 <strong>指定IP地址</strong> 的 <strong>指定端口</strong> 发送一个 <strong>指定内容</strong> 的 UDP 数据报，这个小程序的代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">        int sockfd;</span><br><span class="line">        struct sockaddr_in server;</span><br><span class="line">        char msg[20]=&#123;0&#125;;</span><br><span class="line">        </span><br><span class="line">        sockfd = socket(AF_INET,SOCK_DGRAM,0);</span><br><span class="line">        <span class="keyword">if</span> (sockfd &lt; 0) &#123;</span><br><span class="line">                perror(<span class="string">"socket error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(-1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        memset(&amp;server,0,sizeof(server));</span><br><span class="line">        server.sin_family = AF_INET;</span><br><span class="line">        server.sin_addr.s_addr = inet_addr(<span class="string">"192.168.1.1"</span>);</span><br><span class="line">        server.sin_port = htons(7777);</span><br><span class="line">        </span><br><span class="line">        strncpy(msg,<span class="string">"hello"</span>,sizeof(<span class="string">"hello"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"send message:%s\n"</span>,msg);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (sendto(sockfd,msg,20,0,(struct sockaddr *)&amp;server,sizeof(server)) != 20) &#123;</span><br><span class="line">                perror(<span class="string">"sendto error!\n"</span>);</span><br><span class="line">                <span class="built_in">exit</span>(-1);</span><br><span class="line">        &#125;        </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">exit</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 C 程序会向 IP 地址 192.168.1.1 的 7777 端口 发送一条 “hello” 消息。你可以用编辑器修改程序，向不同的 IP 不同的 IP 发送不同的内容。</p>
<p>然后安装一个知名的抓包工具<strong>tcpdump</strong>，并运行<strong>tcpdump</strong></p>
<p><strong>Ubuntu下：</strong></p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install tcpdump
$ sudo tcpdump -vvv -X udp port 7777
</code></pre><p><strong>CentOS/RedHat下：</strong></p>
<pre><code># yum install tcpdump
# tcpdump -vvv -X udp port 7777
</code></pre><p>最后另启动一个终端，编译运行刚才编写的C语言小程序<strong>test.c</strong>：</p>
<pre><code># gcc -o test test.c
# ./test
</code></pre><p>test 程序运行结束，返回刚才运行 tcpdump 的终端查看抓包结果</p>
<h1 id="传输层：TCP协议"><a href="#传输层：TCP协议" class="headerlink" title="传输层：TCP协议"></a>传输层：TCP协议</h1><hr>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TCP 和 UDP 处在同一层——运输层，但是它们有很多的不同。TCP 是 TCP/IP 系列协议中最复杂的部分，它具有以下特点：</p>
<blockquote>
<ul>
<li>(1) TCP 提供 <strong>可靠的</strong> 数据传输服务，TCP 是 <strong>面向连接</strong>的 。应用程序在使用 TCP 通信之前，先要建立连接，这是一个类似“打电话”的过程，通信结束后还要“挂电话”</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(2) TCP 连接是 <strong>点对点</strong> 的，一条 TCP 连接只能连接两个端点</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(3) TCP 提供可靠传输，无差错、不丢失、不重复、按顺序</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(4) TCP 提供 <strong>全双工</strong> 通信，允许通信双方任何时候都能发送数据，因为 TCP 连接的两端都设有发送缓存和接收缓存</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(5) TCP 面向 字节流, TCP 并不知道所传输的数据的含义，仅把数据看作一连串的字节序列，它也不保证接收方收到的数据块和发送方发出的数据块具有大小对应关系</li>
</ul>
</blockquote>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_20.png" alt=""></p>
<h2 id="TCP-报文段结构"><a href="#TCP-报文段结构" class="headerlink" title="TCP 报文段结构"></a>TCP 报文段结构</h2><p>TCP 是面向字节流的，而 TCP 传输数据的单元是 <strong>报文段</strong> 。一个 TCP 报文段可分为两部分：报头和数据部分。数据部分是上层应用交付的数据，而报头则是 TCP 功能的关键。</p>
<p>TCP 报文段的报头有前 20 字节的固定部分，后面 4n 字节是根据需要而添加的字段。如图则是 TCP 报文段结构：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_21.png" alt=""></p>
<p>20 字节的固定部分，各字段功能说明：</p>
<blockquote>
<ul>
<li>1.<strong>源端口和目的端口</strong>:各占 2 个字节，分别写入源端口号和目的端口号。这和 UDP 报头有类似之处，因为都是运输层协议。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>2.<strong>序号</strong>:占 4 字节序，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。 TCP 是面向字节流的，通过 TCP 传送的字节流中的每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的<strong>第一个字节的序号</strong>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>3.<strong>确认序号</strong>:占 4 字节，期望收到对方下个报文段的第一个数据字节的序号。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>4.<strong>数据偏移</strong>:占 4 位，指 TCP 报文段的报头长度，包括固定的 20 字节和选项字段。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>5.<strong>保留</strong>:占 6 位，保留为今后使用，目前为 0。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>6.<strong>控制位</strong>:共有 6 个控制位，说明本报文的性质，意义如下：</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li><strong>URG 紧急</strong>:当 URG=1 时，它告诉系统此报文中有紧急数据，应优先传送(比如紧急关闭)，这要与<strong>紧急指针</strong>字段配合使用。</li>
<li><strong>ACK 确认</strong>:仅当 ACK=1 时<strong>确认号</strong>字段才有效。建立 TCP 连接后，所有报文段都必须把 ACK 字段置为 1。</li>
<li><strong>PSH 推送</strong>:若 TCP 连接的一端希望另一端立即响应，PSH 字段便可以“催促”对方，不再等到缓存区填满才发送。</li>
<li><strong>RET 复位</strong>:若 TCP 连接出现严重差错，RST 置为 1，断开 TCP 连接，再重新建立连接。</li>
<li><strong>SYN 同步</strong>:用于建立和释放连接，稍后会详细介绍。</li>
<li><strong>FIN 终止</strong>:用于释放连接，当 FIN=1，表明发送方已经发送完毕，要求释放 TCP 连接。</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>7.<strong>窗口</strong>:占 2 个字节。窗口值是指发送者自己的接收窗口大小，因为接收缓存的空间有限。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>8.<strong>检验和</strong>:2 个字节。和 UDP 报文一样，有一个检验和，用于检查报文是否在传输过程中出差错。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>9.<strong>紧急指针</strong>:2 字节。当 URG=1 时才有效，指出本报文段紧急数据的字节数。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>10.<strong>选项</strong>:长度可变，最长可达 40 字节。具体的选项字段，需要时再做介绍。</li>
</ul>
</blockquote>
<h2 id="连接的建立和释放"><a href="#连接的建立和释放" class="headerlink" title="连接的建立和释放"></a>连接的建立和释放</h2><p>刚才说过，TCP 是面向连接的，在传输 TCP 报文段之前先要创建连接，发起连接的一方被称为客户端，而响应连接请求的一方被称为服务端，而这个创建连接的过程被称为 <strong>三次握手</strong>：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_22.png" alt=""></p>
<blockquote>
<ul>
<li>(1) 客户端发出请求连接报文段，其中报头控制位 SYN=1，初始序号 seq=x。客户端进入 SYN-SENT(同步已发送)状态。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(2) 服务端收到请求报文段后，向客户端发送确认报文段。确认报文段的首部中 SYN=1，ACK=1，确认号是 ack=x+1，同时为自己选择一个初始序号 seq=y。服务端进入 SYN-RCVD(同步收到)状态。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(3) 客户端收到服务端的确认报文段后，还要给服务端发送一个确认报文段。这个报文段中 ACK=1，确认号 ack=y+1，而自己的序号 seq=x+1。这个报文段已经可以携带数据，如果不携带数据则不消耗序号，则下一个报文段序号仍为 seq=x+1。</li>
</ul>
</blockquote>
<p>至此 TCP 连接已经建立，客户端进入 ESTABLISHED(已建立连接)状态，当服务端收到确认后，也进入 ESTABLISHED 状态，它们之间便可以正式传输数据了。</p>
<p>当传输数据结束后，通信双方都可以释放连接，这个释放连接过程被称为 <strong>释放连接</strong> :</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_23.png" alt=""></p>
<blockquote>
<ul>
<li>(1) 此时 TCP 连接两端都还处于 ESTABLISHED 状态，客户端停止发送数据，并发出一个 FIN 报文段。首部 FIN=1，序号 seq=u（u 等于客户端传输数据最后一字节的序号加 1）。客户端进入 FIN-WAIT-1(终止等待 1)状态。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(2) 服务端回复确认报文段，确认号 ack=u+1，序号 seq=v（v 等于服务端传输数据最后一字节的序号加 1），服务端进入 CLOSE-WAIT(关闭等待)状态。现在 TCP 连接处于半开半闭状态，服务端如果继续发送数据，客户端依然接收。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(3) 客户端收到确认报文，进入 FIN-WAIT-2 状态，服务端发送完数据后，发出 FIN 报文段，FIN=1，确认号 ack=u+1，然后进入 LAST-ACK(最后确认)状态。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(4) 客户端回复确认确认报文段，ACK=1，确认号 ack=w+1（w 为半开半闭状态时，收到的最后一个字节数据的编号） ，序号 seq=u+1，然后进入 TIME-WAIT(时间等待)状态。</li>
</ul>
</blockquote>
<p><strong>注意此时连接还没有释放，需要时间等待状态结束后(4 分钟) 连接两端才会 CLOSED。设置时间等待是因为，有可能最后一个确认报文丢失而需要重传。</strong></p>
<h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><blockquote>
<ul>
<li>(1) TCP 报文段的长度可变，根据收发双方的缓存状态、网络状态而调整。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(2) 当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(3) 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到一个确认，将重发这个报文段。这就是稍后介绍的<strong>超时重传</strong>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(4) TCP 将保持它首部和数据的检验和。如果通过检验和发现报文段有差错，这个报文段将被丢弃，等待超时重传。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(5) TCP 将数据按字节排序，报文段中有序号，以确保顺序的正确性。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>(6) TCP 还能提供流量控制。TCP 连接的每一方都有收发缓存。<strong>TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据</strong>。这将防止较快主机致使较慢主机的缓冲区溢出。</li>
</ul>
</blockquote>
<p>可见超时重发机制是 TCP 可靠性的关键，只要没有得到确认报文段，就重新发送数据报，直到收到对方的确认为止。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP 规定，接收者收到数据报文段后，需回复一个确认报文段，以告知发送者数据已经收到。而发送者如果一段时间内<strong>(超时计时器)</strong>没有收到确认报文段，便重复发送：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_24.png" alt=""></p>
<p>为了实现超时间重传，需要注意：</p>
<blockquote>
<ul>
<li>1.发送者发送一个报文段后，<strong>暂时保存该报文段的副本</strong>，为发生超时重传时使用，收到确认报文后删除该报文段。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>2.确认报文段也需要序号，才能明确是发出去的那个数据报得到了确认。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>3.超时计时器比传输往返时间略长，但具体值是不确定的，根据网络情况而变。</li>
</ul>
</blockquote>
<h2 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h2><p>也许你也发现了，按上面的介绍，超时重传机制很费时间，每发送一个数据报都要等待确认。</p>
<p>在实际应用中的确不是这样的，真实情况是，采用了<strong>流水线传输</strong>：发送方可以连续发送多个报文段(连续发送的数据长度叫做窗口)，而不必每发完一段就停下来等待确认。</p>
<p>实际应用中，接收方也不必对收到的每个报文都做回复，而是采用<strong>累积确认</strong>方式：接收者收到多个连续的报文段后，只回复确认最后一个报文段，表示在这之前的数据都已收到。</p>
<p>这样，传输效率得到了很大的提升。</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_25.png" alt=""></p>
<h2 id="流量控制和拥塞控制"><a href="#流量控制和拥塞控制" class="headerlink" title="流量控制和拥塞控制"></a>流量控制和拥塞控制</h2><p>由于接收方缓存的限制，发送窗口不能大于接收方接收窗口。在报文段首部有一个字段就叫做<strong>窗口(rwnd)</strong>，这便是用于告诉对方自己的接收窗口，可见窗口的大小是可以变化的。</p>
<p>那么窗口的大小是如何变化的呢？TCP 对于拥塞的控制总结为<strong>“慢启动、加性增、乘性减”</strong>，如图所示：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_26.png" alt=""></p>
<blockquote>
<ul>
<li>慢启动 ：初始的窗口值很小，但是按指数规律渐渐增长，直到达到<strong>慢开始门限(ssthresh)</strong>。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>加性增 ：窗口值达到慢开始门限后，每发送一个报文段，窗口值增加一个单位量。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>乘性减 ：无论什么阶段，只要出现超时，则把窗口值减小一半。</li>
</ul>
</blockquote>
<h2 id="tcpdump-抓取-TCP-报文段"><a href="#tcpdump-抓取-TCP-报文段" class="headerlink" title="tcpdump 抓取 TCP 报文段"></a>tcpdump 抓取 TCP 报文段</h2><p>现在我们尝试用 tcpdump 抓取TCP报文，首先还是要安装并运行 tcpdump：</p>
<p><strong>Ubuntu下：</strong></p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install tcpdump
$ sudo tcpdump -vvv -X -i lo tcp port 7777
</code></pre><p><strong>CentOS/RedHat下：</strong></p>
<pre><code># yum install tcpdump
# tcpdump -vvv -X -i lo tcp port 7777
</code></pre><p>然后编写一个基于 TCP 的聊天小程序，分为 server(服务端)和 client(客户端)：</p>
<p><strong>Server端程序：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFLEN 10</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd, newfd;</span><br><span class="line">    struct sockaddr_in s_addr, c_addr;</span><br><span class="line">    char buf[BUFLEN];</span><br><span class="line">    socklen_t len;</span><br><span class="line">    unsigned int port, listnum;</span><br><span class="line">    </span><br><span class="line">    /*建立socket*/</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)&#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    /*设置服务器端口*/    </span><br><span class="line">    <span class="keyword">if</span>(argv[2])</span><br><span class="line">        port = atoi(argv[2]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        port = 7777;</span><br><span class="line">    /*设置侦听队列长度*/</span><br><span class="line">    <span class="keyword">if</span>(argv[3])</span><br><span class="line">        listnum = atoi(argv[3]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        listnum = 3;</span><br><span class="line">    /*设置服务器ip*/</span><br><span class="line">    bzero(&amp;s_addr, sizeof(s_addr));</span><br><span class="line">    s_addr.sin_family = AF_INET;</span><br><span class="line">    s_addr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span>(argv[1])</span><br><span class="line">        s_addr.sin_addr.s_addr = inet_addr(argv[1]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s_addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line">    /*把地址和端口帮定到套接字上*/</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">bind</span>(sockfd, (struct sockaddr*) &amp;s_addr,sizeof(struct sockaddr))) == -1)&#123;</span><br><span class="line">        perror(<span class="string">"bind"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    /*侦听本地端口*/</span><br><span class="line">    <span class="keyword">if</span>(listen(sockfd,listnum) == -1)&#123;</span><br><span class="line">        perror(<span class="string">"listen"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*****************server start***************\n"</span>);</span><br><span class="line">        len = sizeof(struct sockaddr);</span><br><span class="line">        <span class="keyword">if</span>((newfd = accept(sockfd,(struct sockaddr*) &amp;c_addr, &amp;len)) == -1)&#123;</span><br><span class="line">            perror(<span class="string">"accept"</span>);        </span><br><span class="line">            <span class="built_in">exit</span>(errno);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        _retry:</span><br><span class="line">            /******发送消息*******/</span><br><span class="line">            bzero(buf,BUFLEN);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"enter your words:"</span>);</span><br><span class="line">            /*fgets函数：从流中读取BUFLEN-1个字符*/</span><br><span class="line">            fgets(buf,BUFLEN,stdin);</span><br><span class="line">            /*打印发送的消息*/</span><br><span class="line">            //fputs(buf,stdout);</span><br><span class="line">            <span class="keyword">if</span>(!strncasecmp(buf,<span class="string">"quit"</span>,4))&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"server stop\n"</span>);</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            /*如果输入的字符串只有<span class="string">"\n"</span>，即回车，那么请重新输入*/</span><br><span class="line">            <span class="keyword">if</span>(!strncmp(buf,<span class="string">"\n"</span>,1))&#123;</span><br><span class="line">                </span><br><span class="line">                goto _retry;</span><br><span class="line">            &#125;    </span><br><span class="line">            /*如果buf中含有<span class="string">'\n'</span>，那么要用strlen(buf)-1，去掉<span class="string">'\n'</span>*/            </span><br><span class="line">            <span class="keyword">if</span>(strchr(buf,<span class="string">'\n'</span>))</span><br><span class="line">                len = send(newfd,buf,strlen(buf)-1,0);</span><br><span class="line">            /*如果buf中没有<span class="string">'\n'</span>，则用buf的真正长度strlen(buf)*/    </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                len = send(newfd,buf,strlen(buf),0);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; 0)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"send successful\n"</span>);            </span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"send failed\n"</span>);</span><br><span class="line">                <span class="built_in">break</span>;            </span><br><span class="line">            &#125;</span><br><span class="line">            /******接收消息*******/</span><br><span class="line">            bzero(buf,BUFLEN);</span><br><span class="line">            len = recv(newfd,buf,BUFLEN,0);</span><br><span class="line">            <span class="keyword">if</span>(len &gt; 0)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"receive massage:%s\n"</span>,buf);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; 0 )</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"receive failed\n"</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"client stop\n"</span>);</span><br><span class="line">                <span class="built_in">break</span>;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        /*关闭聊天的套接字*/</span><br><span class="line">        close(newfd);</span><br><span class="line">        /*是否退出服务器*/</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exit?：y-&gt;yes；n-&gt;no "</span>);</span><br><span class="line">        bzero(buf, BUFLEN);</span><br><span class="line">        fgets(buf,BUFLEN, stdin);</span><br><span class="line">        <span class="keyword">if</span>(!strncasecmp(buf,<span class="string">"y"</span>,1))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"server stop\n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*关闭服务器的套接字*/</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Client端程序：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;errno.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/socket.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;arpa/inet.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;netinet/in.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define BUFLEN 10</span></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int sockfd;</span><br><span class="line">    struct sockaddr_in s_addr;</span><br><span class="line">    socklen_t len;</span><br><span class="line">    unsigned int port;</span><br><span class="line">    char buf[BUFLEN];    </span><br><span class="line">    </span><br><span class="line">    /*建立socket*/</span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)&#123;</span><br><span class="line">        perror(<span class="string">"socket"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    /*设置服务器端口*/    </span><br><span class="line">    <span class="keyword">if</span>(argv[2])</span><br><span class="line">        port = atoi(argv[2]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        port = 7777;</span><br><span class="line">    /*设置服务器ip*/</span><br><span class="line">    bzero(&amp;s_addr, sizeof(s_addr));</span><br><span class="line">    s_addr.sin_family = AF_INET;</span><br><span class="line">    s_addr.sin_port = htons(port);</span><br><span class="line">    <span class="keyword">if</span> (inet_aton(argv[1], (struct in_addr *)&amp;s_addr.sin_addr.s_addr) == 0) &#123;</span><br><span class="line">        perror(argv[1]);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    /*开始连接服务器*/    </span><br><span class="line">    <span class="keyword">if</span>(connect(sockfd,(struct sockaddr*)&amp;s_addr,sizeof(struct sockaddr)) == -1)&#123;</span><br><span class="line">        perror(<span class="string">"connect"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"*****************client start***************\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(1)&#123;</span><br><span class="line">        /******接收消息*******/</span><br><span class="line">        bzero(buf,BUFLEN);</span><br><span class="line">        len = recv(sockfd,buf,BUFLEN,0);</span><br><span class="line">        <span class="keyword">if</span>(len &gt; 0)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"receive massage:%s\n"</span>,buf);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(len &lt; 0 )</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"receive failed\n"</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"server stop\n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    _retry:    </span><br><span class="line">        /******发送消息*******/    </span><br><span class="line">        bzero(buf,BUFLEN);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"enter your words:"</span>);</span><br><span class="line">        /*fgets函数：从流中读取BUFLEN-1个字符*/</span><br><span class="line">        fgets(buf,BUFLEN,stdin);</span><br><span class="line">        /*打印发送的消息*/</span><br><span class="line">        //fputs(buf,stdout);</span><br><span class="line">        <span class="keyword">if</span>(!strncasecmp(buf,<span class="string">"quit"</span>,4))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"client stop\n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        /*如果输入的字符串只有<span class="string">"\n"</span>，即回车，那么请重新输入*/</span><br><span class="line">        <span class="keyword">if</span>(!strncmp(buf,<span class="string">"\n"</span>,1))&#123;</span><br><span class="line">            </span><br><span class="line">            goto _retry;</span><br><span class="line">        &#125;</span><br><span class="line">        /*如果buf中含有<span class="string">'\n'</span>，那么要用strlen(buf)-1，去掉<span class="string">'\n'</span>*/    </span><br><span class="line">        <span class="keyword">if</span>(strchr(buf,<span class="string">'\n'</span>))</span><br><span class="line">            len = send(sockfd,buf,strlen(buf)-1,0);</span><br><span class="line">        /*如果buf中没有<span class="string">'\n'</span>，则用buf的真正长度strlen(buf)*/    </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            len = send(sockfd,buf,strlen(buf),0);</span><br><span class="line">        <span class="keyword">if</span>(len &gt; 0)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"send successful\n"</span>);            </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"send failed\n"</span>);</span><br><span class="line">            <span class="built_in">break</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /*关闭连接*/</span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后分别编译并运行Server端和Client端程序：</p>
<pre><code># gcc -o Server Server.c
# ./Server 127.0.0.1

# gcc -o Client Client.c
# ./Client 127.0.0.1
</code></pre><h1 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h1><hr>
<p>在传输层之上，便是应用层。传输层的 UDP 报文和 TCP 报文段的数据部分就是应用层交付的数据。</p>
<p>不同类型的网络应用有不同的通信规则，因此应用层协议是多种多样的，比如 DNS、FTP、Telnet、SMTP、HTTP、RIP、NFS 等协议都是用于解决其各自的一类问题。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS (Domain Name Service 域名服务) 协议基于 UDP，使用端口号 53。</p>
<p>由数字组成的 IP 地址很难记忆，所以我们上网使用网站 IP 地址的别名——域名。实际使用中，域名与 IP 地址是对应的，这种对应关系保存在 <strong>DNS服务器</strong> 之中。</p>
<p>在浏览器中输入一个域名后，会有 DNS 服务器将域名解析为对应的 IP 地址。注意这和网络层的 ARP 协议的不同之处：DNS 提供的是域名与 IP 地址的对应关系，而 ARP 提供的是 IP 地址和 MAC 地址的对应关系。</p>
<h3 id="DNS-服务器"><a href="#DNS-服务器" class="headerlink" title="DNS 服务器"></a>DNS 服务器</h3><p>DNS 服务器是个分层次的系统：</p>
<blockquote>
<ul>
<li><strong>根 DNS 服务器</strong> ：全世界共有 13 台根域名服务器，编号 A 到 M，其中大部分位于美国</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>顶级(TLD)DNS 服务器</strong> ：负责如 com 、org 、edu 等顶级域名和所有国家的顶级域名(如 cn 、uk 、jp )</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>权威 DNS 服务器</strong> ：大型组织、大学、企业的域名解析服务</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>本地 DNS 服务器</strong> ：通常与我们主机最近的 DNS 服务器</li>
</ul>
</blockquote>
<p>而域名解析的过程，有迭代查询和递归查询两种方式：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_27.png" alt=""></p>
<h3 id="host命令"><a href="#host命令" class="headerlink" title="host命令"></a>host命令</h3><p>在 linux 系统中，可以用 <code>host</code> 命令 进行 DNS 查询，查看一个指定域名的 IP，比如要查询 百度 的IP地址：</p>
<pre><code>host www.baidu.com
</code></pre><h3 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h3><p>主机向 DNS 服务器发出的查询叫做<strong>DNS报文</strong>，大致结构：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_28.png" alt=""></p>
<p>DNS 问答报文的内容，都是 IP 和域名的对应信息，关于 DNS 首部和内容 各字段这里不做详细介绍。深入了解，可以先 host 一个域名，再使用 tcpdump 抓取报文并解读。</p>
<h3 id="DNS-缓存和-hosts-文件"><a href="#DNS-缓存和-hosts-文件" class="headerlink" title="DNS 缓存和 hosts 文件"></a>DNS 缓存和 hosts 文件</h3><p>刚才 DNS 解析查询过程的图中，共发出了 8 份 DNS 报文，这是非常消耗时间的，所以实际应用上使用 <strong>DNS 缓存</strong> ：当一个 DNS 服务器接收到一个 DNS 回答后，会将其信息缓存一段时间，当再有一个对相同域名的查询时，便可直接回复。</p>
<p>通过 DNS 缓存，其实很多查询都只需要本地 DNS 服务器便可完成。</p>
<p>有“翻墙”爱好的同学应该知道 hosts 文件，其实 hosts 文件可以看作是一个小型的 DNS 服务器。</p>
<p>使用命令打开 hosts 文件：</p>
<pre><code># vim /etc/hosts
</code></pre><p>查看文件内容，可以发现里面全是类似下图中的 IP 和域名对应记录：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_29.png" alt=""></p>
<p>在实际上网过程中，域名解析的的优先顺序是：先在 DNS 缓存查询，若没有找到记录，再查询 hosts 文件，若还是没找到记录，再向 DNS 服务器发出 DNS 查询报文。</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP (File Transfer Protocol 文件传输协议) 基于 TCP，使用端口号 20(数据)和 21(控制)。</p>
<p>它的主要功能是减少或消除在不同操作系统下处理文件的不兼容性，以达到便捷高效的文件传输效果。</p>
<blockquote>
<ul>
<li>FTP 只提供文件传输的基本服务，它采用 客户端—服务器 的方式，一个 FTP 服务器可同时为多个客户端提供服务</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>在进行文件传输时，FTP 的客户端和服务器之间会建立两个 TCP 连接：21 号端口建立<strong>控制连接</strong>，20 号端口建立<strong>数据连接</strong></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>FTP 的传输有两种方式：ASCII 传输模式和二进制数据传输模式</li>
</ul>
</blockquote>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP (HyperText Transfer Protocol 超文本传输协议) 基于 TCP，使用端口号 80 或 8080。</p>
<p>每当你在浏览器里输入一个网址或点击一个链接时，浏览器就通过 HTTP 协议将网页信息从服务器提取再显示出来，这是现在使用频率最大的应用层协议。</p>
<p>这个原理很简单：</p>
<blockquote>
<ul>
<li>点击一个链接后，浏览器向服务器发起 TCP 连接</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>连接建立后浏览器发送 HTTP 请求报文，然后服务器回复响应报文</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>浏览器将收到的响应报文内容显示在网页上</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>报文收发结束，关闭 TCP 连接</li>
</ul>
</blockquote>
<p>HTTP 报文会被传输层封装为 TCP 报文段，然后再被 IP 层封装为 IP 数据报。HTTP 报文的结构：</p>
<p><img src="https://img.koenli.com/TCP/IP%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_30.png" alt=""></p>
<p>可见报文分为 3 部分：</p>
<blockquote>
<ul>
<li><strong>开始行</strong>：用于区分是请求报文还是响应报文，请求报文中开始行叫做<strong>请求行</strong>，而响应报文中，开始行叫做<strong>状态行*</strong>。在开始行的三个字段之间都用空格分开，结尾处 CRLF 表示回车和换行。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>首部行</strong>：用于说明浏览器、服务器或报文主体的一些信息。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><strong>实体主体</strong>：请求报文中通常不用实体主体。</li>
</ul>
</blockquote>
<p>请求报文的方法字段是对所请求对象进行的操作，而响应报文的状态码是一个 3 位数字，分为 5 类 33 种：</p>
<blockquote>
<ul>
<li>1xx 表示通知信息，如收到或正在处理</li>
<li>2xx 表示成功接收</li>
<li>3xx 表示重定向</li>
<li>4xx 表示客户的差错，如 404 表示网页未找到</li>
<li>5xx表示服务器的差错，如常见的 502 Bad Gateway</li>
</ul>
</blockquote>
<ul>
<li>EOF</li>
</ul>
<p>本文作者：Koen</p>
<p>参考链接：<a href="https://www.shiyanlou.com/courses/98" target="_blank" rel="noopener">https://www.shiyanlou.com/courses/98</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络/" rel="tag"># 网络</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ck4fw0uo4001gi9kco3qz5z69.html" rel="next" title="Git简明教程">
                <i class="fa fa-chevron-left"></i> Git简明教程
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/ck4fw0uoj002qi9kcnpqrdusx.html" rel="prev" title="扩展正则表达式">
                扩展正则表达式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="Koenli" />
            
              <p class="site-author-name" itemprop="name">Koenli</p>
              <p class="site-description motion-element" itemprop="description">想要出类拔萃，就要做别人不想做的事</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#TCP-IP简介"><span class="nav-number">1.</span> <span class="nav-text">TCP/IP简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP背景和介绍"><span class="nav-number">1.1.</span> <span class="nav-text">TCP/IP背景和介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络协议栈架构"><span class="nav-number">1.1.1.</span> <span class="nav-text">网络协议栈架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预备知识"><span class="nav-number">1.2.</span> <span class="nav-text">预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IP地址"><span class="nav-number">1.2.1.</span> <span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#域名"><span class="nav-number">1.2.2.</span> <span class="nav-text">域名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAC地址"><span class="nav-number">1.2.3.</span> <span class="nav-text">MAC地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#端口号"><span class="nav-number">1.2.4.</span> <span class="nav-text">端口号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装与分用"><span class="nav-number">1.2.5.</span> <span class="nav-text">封装与分用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RFC"><span class="nav-number">1.2.6.</span> <span class="nav-text">RFC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#链路层介绍"><span class="nav-number">2.</span> <span class="nav-text">链路层介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制帧的传输"><span class="nav-number">2.2.</span> <span class="nav-text">控制帧的传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#差错控制"><span class="nav-number">2.2.1.</span> <span class="nav-text">差错控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反馈重发"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">反馈重发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计时器"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">计时器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序号"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">序号</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量控制"><span class="nav-number">2.2.2.</span> <span class="nav-text">流量控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以太网"><span class="nav-number">2.3.</span> <span class="nav-text">以太网</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PPP（点对点协议）"><span class="nav-number">2.4.</span> <span class="nav-text">PPP（点对点协议）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SLIP-与-PPP"><span class="nav-number">2.5.</span> <span class="nav-text">SLIP 与 PPP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SLIP协议"><span class="nav-number">2.5.1.</span> <span class="nav-text">SLIP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PPP协议"><span class="nav-number">2.5.2.</span> <span class="nav-text">PPP协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MTU"><span class="nav-number">2.6.</span> <span class="nav-text">MTU</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IP-网际协议"><span class="nav-number">3.</span> <span class="nav-text">IP 网际协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#IP数据报"><span class="nav-number">3.1.</span> <span class="nav-text">IP数据报</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-地址分类"><span class="nav-number">3.2.</span> <span class="nav-text">IP 地址分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#子网划分"><span class="nav-number">3.3.</span> <span class="nav-text">子网划分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-路由选择"><span class="nav-number">3.4.</span> <span class="nav-text">IP 路由选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NAT-技术"><span class="nav-number">3.5.</span> <span class="nav-text">NAT 技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP-的未来"><span class="nav-number">3.6.</span> <span class="nav-text">IP 的未来</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#网络层其它协议"><span class="nav-number">4.</span> <span class="nav-text">网络层其它协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP-Address-Resolution-Protocol-地址解析协议"><span class="nav-number">4.1.</span> <span class="nav-text">ARP(Address Resolution Protocol)地址解析协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#功能"><span class="nav-number">4.1.1.</span> <span class="nav-text">功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">4.1.2.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP代理"><span class="nav-number">4.1.3.</span> <span class="nav-text">ARP代理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP-欺骗"><span class="nav-number">4.1.4.</span> <span class="nav-text">ARP 欺骗</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RARP-Reverse-Address-Resolution-Protocol-逆向地址解析协议"><span class="nav-number">4.2.</span> <span class="nav-text">RARP(Reverse Address Resolution Protocol)逆向地址解析协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP-Internet-Control-Message-Protocol-控制报文协议"><span class="nav-number">4.3.</span> <span class="nav-text">ICMP(Internet Control Message Protocol)控制报文协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ping-程序和-traceroute-程序"><span class="nav-number">4.4.</span> <span class="nav-text">ping 程序和 traceroute 程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ping"><span class="nav-number">4.4.1.</span> <span class="nav-text">ping</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#traceroute"><span class="nav-number">4.4.2.</span> <span class="nav-text">traceroute</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IGMP-Internet-Group-Management-Protocol-组管理协议"><span class="nav-number">4.5.</span> <span class="nav-text">IGMP(Internet Group Management Protocol)组管理协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传输层：UDP协议"><span class="nav-number">5.</span> <span class="nav-text">传输层：UDP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#传输层协议"><span class="nav-number">5.1.</span> <span class="nav-text">传输层协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#端口"><span class="nav-number">5.2.</span> <span class="nav-text">端口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-概述"><span class="nav-number">5.3.</span> <span class="nav-text">UDP 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP报文"><span class="nav-number">5.4.</span> <span class="nav-text">UDP报文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcpdump-抓取-UDP-报文"><span class="nav-number">5.5.</span> <span class="nav-text">tcpdump 抓取 UDP 报文</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#传输层：TCP协议"><span class="nav-number">6.</span> <span class="nav-text">传输层：TCP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">6.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-报文段结构"><span class="nav-number">6.2.</span> <span class="nav-text">TCP 报文段结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接的建立和释放"><span class="nav-number">6.3.</span> <span class="nav-text">连接的建立和释放</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-可靠传输的实现"><span class="nav-number">6.4.</span> <span class="nav-text">TCP 可靠传输的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超时重传"><span class="nav-number">6.5.</span> <span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续-ARQ-协议"><span class="nav-number">6.6.</span> <span class="nav-text">连续 ARQ 协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流量控制和拥塞控制"><span class="nav-number">6.7.</span> <span class="nav-text">流量控制和拥塞控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcpdump-抓取-TCP-报文段"><span class="nav-number">6.8.</span> <span class="nav-text">tcpdump 抓取 TCP 报文段</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#应用层协议"><span class="nav-number">7.</span> <span class="nav-text">应用层协议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number">7.1.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-服务器"><span class="nav-number">7.1.1.</span> <span class="nav-text">DNS 服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#host命令"><span class="nav-number">7.1.2.</span> <span class="nav-text">host命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS报文"><span class="nav-number">7.1.3.</span> <span class="nav-text">DNS报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS-缓存和-hosts-文件"><span class="nav-number">7.1.4.</span> <span class="nav-text">DNS 缓存和 hosts 文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#FTP"><span class="nav-number">7.2.</span> <span class="nav-text">FTP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">7.3.</span> <span class="nav-text">HTTP</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Koenli</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: 'XD8aPBomWwb9OrD5OlP3F42U-gzGzoHsz',
        appKey: 'EHcp6RUK4G6BGD0dqfrz0IDo',
        placeholder: '想对作者说点什么',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("XD8aPBomWwb9OrD5OlP3F42U-gzGzoHsz", "EHcp6RUK4G6BGD0dqfrz0IDo");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
